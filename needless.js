// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2013, Peter-Paul van Gemerden <info@ppvg.nl>
License: Simplified BSD (2-clause)
         http://opensource.org/licenses/BSD-2-Clause
*/

var circularReference, deleteModule, deleteModuleFromParent, getDescendants, getModuleFromCache, inception, isRelativePath, needless, path, throwErrorIfCircularReference, toFullPath;

path = require('path');

/* Calls needless on itself. See the end of this file for clarification.
*/


inception = function() {
  return needless(module.filename);
};

module.exports = needless = function(moduleName) {
  /*
  Removes a module and all its children from the require cache.
  */

  var mod, parent, _i, _len, _ref;

  throwErrorIfCircularReference();
  parent = getModuleFromCache(moduleName);
  if (parent != null) {
    _ref = getDescendants(parent);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      mod = _ref[_i];
      deleteModule(mod);
    }
    return true;
  }
  return false;
};

throwErrorIfCircularReference = function() {
  var error;

  if (circularReference()) {
    error = new Error('Found a circular reference. Did you run `cake` on a directory?');
    error.code = 'CIRCULAR_REFERENCE';
    throw error;
  }
};

circularReference = function() {
  /*
  Returns true if any module in the require cache has itself as parent.
  */

  var key, mod, _ref, _ref1, _ref2;

  _ref = require.cache;
  for (key in _ref) {
    mod = _ref[key];
    if (mod.filename === ((_ref1 = mod.parent) != null ? _ref1.filename : void 0)) {
      if (mod.filename === ((_ref2 = mod.parent) != null ? _ref2.filename : void 0)) {
        return true;
      }
    }
  }
  return false;
};

getModuleFromCache = function(name) {
  var modulePath;

  if (isRelativePath(name)) {
    name = toFullPath(name);
  }
  modulePath = require.resolve(name);
  return require.cache[modulePath];
};

isRelativePath = function(name) {
  return (name.indexOf('./')) === 0 || (name.indexOf('../') === 0);
};

toFullPath = function(relativePath) {
  var parentDirname;

  parentDirname = path.dirname(module.parent.filename);
  return path.join(parentDirname, relativePath);
};

getDescendants = function(parent) {
  /*
  Returns array with parent and all direct and indirect descendents.
  */

  var descendants, recurse;

  descendants = [];
  (recurse = function(parent) {
    descendants.push(parent);
    return parent.children.forEach(recurse);
  })(parent);
  return descendants;
};

deleteModule = function(mod) {
  delete require.cache[mod.id];
  return deleteModuleFromParent(mod);
};

deleteModuleFromParent = function(mod) {
  /*
  Removes the given module from its parent's `.children`.
  */

  var child, i, _i, _ref, _results;

  _ref = mod.parent.children;
  _results = [];
  for (i = _i = _ref.length - 1; _i >= 0; i = _i += -1) {
    child = _ref[i];
    if (child.id === mod.id) {
      _results.push(mod.parent.children.splice(i, 1));
    }
  }
  return _results;
};

/*
Calling `needless` on itself allows us to re-require needless in nested
modules, without having to worry about relative paths.
*/


inception();
